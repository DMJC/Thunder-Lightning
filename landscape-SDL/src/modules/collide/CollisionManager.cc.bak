#include "CollisionManager.h"
#include <modules/math/Collide.h>

using namespace std;

namespace Collide {

void Collidable::collide(const Contact & c) {
    // do nothing in default implementation
}


void CollisionManager::add(Ptr<Collidable> c) {
    ls_message("geom_instances.insert(make_pair(c, GeometryInstance(c)));\n");
    ls_message("c = %p\n", &*c);
    geom_instances.insert(make_pair(c, new GeometryInstance(c)));
    ls_message("c->integrate(0.0f, geom_instances[c].transforms_1);\n");
    c->integrate(0.0f, geom_instances[c]->transforms_1);
}

void CollisionManager::remove(Ptr<Collidable> c) {
    ls_message("CollisionManager::remove begin\n");
    ls_message("delete geom_instances[c];\n");
    ls_message("c = %p %s.\n", &*c,
        geom_instances.find(c) != geom_instances.end() ? "found" : "not found");
    delete geom_instances[c];
    ls_message("geom_instances.erase(c);\n");
    geom_instances.erase(c);
    ls_message("sweep_n_prune.remove(c);\n");
    sweep_n_prune.remove(c);
    ls_message("CollisionManager::remove done\n");
}

void CollisionManager::run(float delta_t) {
    while (delta_t > 0.0f) {
        for(GeomIter i=geom_instances.begin(); i!=geom_instances.end(); i++) {
            Ptr<Collidable> collidable = i->first;
            GeometryInstance & instance = *i->second;

            swap(instance.transforms_0, instance.transforms_1);
            collidable->integrate(delta_t, instance.transforms_1);

            /*
            ls_message("Transform0: %f %f %f\n",
                instance.transforms_0[0].vec()[0],
                instance.transforms_0[0].vec()[1],
                instance.transforms_0[0].vec()[2]);
            ls_message("Transform1: %f %f %f\n",
                instance.transforms_1[0].vec()[0],
                instance.transforms_1[0].vec()[1],
                instance.transforms_1[0].vec()[2]);
            */

            float min_x = instance.transforms_0[0].vec()[0],
                max_x = instance.transforms_1[0].vec()[0];
            if (min_x > max_x) swap(min_x, max_x);
            //ls_message("min_x = %f max_x = %f\n", min_x, max_x);
            float r = collidable->getBoundingGeometry()->getBoundingRadius();
            sweep_n_prune.set(collidable, min_x - r, max_x + r);
        }

        possible_contacts.clear();
        sweep_n_prune.findContacts(possible_contacts);

        for(ContactIter i=possible_contacts.begin(); i!= possible_contacts.end(); i++) {
            ls_message("Possible collision: %p <-> %p\n", &*i->first, &*i->second);

            if (geom_instances.find(i->first) == geom_instances.end()) continue;
            if (geom_instances.find(i->second) == geom_instances.end()) continue;

            float t0, t1;
            Ptr<Collidable> a = i->first, b = i->second;
            GeometryInstance & a_i = *geom_instances[a];
            GeometryInstance & b_i = *geom_instances[b];
            const Vector & a_p0 = a_i.transforms_0->vec();
            const Vector & a_p1 = a_i.transforms_1->vec();
            const Vector & b_p0 = b_i.transforms_0->vec();
            const Vector & b_p1 = b_i.transforms_1->vec();
            Vector a_v = (a_p1 - a_p0) / delta_t;
            Vector b_v = (b_p1 - b_p0) / delta_t;
            float a_r = a->getBoundingGeometry()->getBoundingRadius();
            float b_r = b->getBoundingGeometry()->getBoundingRadius();
            if (!Collide::movingPoints(Line(a_p0, a_v), Line(b_p0, b_v),
                a_r, b_r, &t0, &t1)) continue;
            if (t1 < 0.0f || t0 > delta_t) continue;
            t0 = std::max(0.0f, t0);
            t1 = std::min(delta_t, t1);

            /*
            Ptr<IActor> actor = i->first->getActor();
            if (!actor) continue;
            actor->hitTarget(1000.0f);
            */

            Vector position = a_p0 + t0*a_v
                + a_r * ((b_p0 + t0*b_v) - (a_p0 + t0*a_v)) / (a_r+b_r);
            Vector normal = (a_p0 + t0*a_v) - (b_p0 + t0*b_v);
            if (normal.length() < 0.00001f) continue;
            normal.normalize();

            if ((a_v-b_v)*normal > 0) continue;
            Contact contact = {
                {a,b},
                {0,0},
                position,
                normal};

            a->collide(contact);
            b->collide(contact);

            Ptr<RigidBody> rigid_a = a->getRigid();
            Ptr<RigidBody> rigid_b = b->getRigid();

            if (!rigid_a || !rigid_b) continue;

            float j = RigidBody::collisionImpulseMagnitude(
                0.2, *rigid_a, *rigid_b, position, normal);

            rigid_a->applyImpulseAt( j * normal, position);
            rigid_b->applyImpulseAt(-j * normal, position);
        }

        for(GeomIter i=geom_instances.begin(); i!=geom_instances.end(); i++) {
            Ptr<Collidable> collidable = i->first;
            GeometryInstance & instance = *i->second;
            collidable->update(delta_t, instance.transforms_1);
        }

}


} // namespace Collide


#include "LoDTerrain.h"
#include <algorithm>
#include <modules/math/Collide.h>

#define ENABLE_DYNAMIC_LOD 1
#define ENABLE_TEXTURING 1
#define ENABLE_BIG_TEXTURE 1
#define ENABLE_NEIGHBOR_DEBUGGING 0
#define ENABLE_LIGHTMAP 1

#define ERROR_FACTOR 200.0
//#define MAX_ERROR 0.005
//#define MAX_ERROR 1.0
#define MAX_ERROR 0.001

#define USE_Z_METRIC 0
#define USE_DISTANCE_METRIC 0
#define USE_ANGULAR_METRIC 0
#define USE_EDGE_METRIC 0
#define USE_BOUNDING_SPHERE_METRIC 0
#define USE_BOUNDING_SPHERE_DISTANCE_METRIC 1

#define DETAIL_LAYERS 3
#define DETAIL_SCALE 40.0
#define DETAIL_TEX_MAX_RANGE 10000.0
#define DETAIL_TEX_MIN_RANGE 1500.0
#define ENABLE_DETAIL_TEX 0

#define TEX_MIN_RANGE 2500.0


#define LEFT 0
#define RIGHT 1
#define TOP 2
#define BOTTOM 2

typedef struct {
	char magic[4];
	ju32 triangles;
	ju32 vertices;
} LoDQuadFileHeader;



// BEGIN: LoDQuad methods

LoDQuad::LoDQuad()
{
}

LoDQuad::~LoDQuad()
{
}


void LoDQuad::init (IGame * the_game, std::istream & in, LoDQuad ** neighbor,
                    TexPtr main_tex, TexPtr detail_tex,
                    const char * texmap_name, TexPtr * textures,
                    const char * lightmap_name)
{
    this->textures = textures;
    LoDQuadFileHeader header;
    LoDTriangleFileStruct ftriangle;
    int i;
    Vector v0, v1, v2;
    
    texmap = new Image(texmap_name);
    
    game=the_game;
    
    this->main_tex=main_tex;
    this->detail_tex=detail_tex;
    
    in.read((char*) &header, sizeof (LoDQuadFileHeader));
    
    triangles=header.triangles;
    vertices=header.vertices;
    
    triangle = new LoDTriangle[triangles];
    ls_warning("Init %p: (vertices=%d)\n", this, vertices);
    vx = new float[vertices];
    vy = new float[vertices];
    vz = new float[vertices];
    tex_u = new float[vertices];
    tex_v = new float[vertices];
    
    for (i=0; i<triangles; i++) {
        in.read((char*) &ftriangle, sizeof(LoDTriangleFileStruct));

        triangle[i].error = ftriangle.error;
        triangle[i].flags = ftriangle.flags;
        
        if (triangle[i].flags & TFLAG_HAS_CHILDREN) {
            triangle[i].child[0] = &triangle[ftriangle.child[0]];
            triangle[i].child[1] = &triangle[ftriangle.child[1]];
        } else {
            triangle[i].child[0] = 0;
            triangle[i].child[1] = 0;
        }
        
        triangle[i].vertex[0] = ftriangle.vertex[0];
        triangle[i].vertex[1] = ftriangle.vertex[1];
        triangle[i].vertex[2] = ftriangle.vertex[2];
    }
    
    in.read((char*) vx, sizeof(float) * vertices);
    in.read((char*) vz, sizeof(float) * vertices);
    in.read((char*) vy, sizeof(float) * vertices);
    
    for (i=0; i<vertices; i++) {
        vz[i]=-vz[i];
        //vy[i]/=3.0;
        //vy[i]*=3.0;
    }
    
    // Measure dimensions and calc texture coords
    float x0 = vx[triangle[0].vertex[2]];
    float z0 = vz[triangle[0].vertex[2]];
    float dx = vx[triangle[0].vertex[1]] - x0;
    float dz = vz[triangle[0].vertex[0]] - z0;
    for (i=0; i<vertices; i++) {
        tex_u[i] = (vx[i] - x0) / dx;
        tex_v[i] = (vz[i] - z0) / dz;
    }
    
    setupBoundingSpheres(&triangle[0]);
    setupBoundingSpheres(&triangle[1]);
    
    for (i=0; i<triangles; i++) {
        //triangle[i].radius = calcRadius( &triangle[i] );
        /*if (i % 1000 == 0) {
            ls_message("radius for tri #%d is %f\n", i, triangle[i].radius);
        }*/
        v0 = Vector(vx[triangle[i].vertex[0]],
                vy[triangle[i].vertex[0]],
                vz[triangle[i].vertex[0]]);
        v1 = Vector(vx[triangle[i].vertex[1]], 
                vy[triangle[i].vertex[1]], 
                vz[triangle[i].vertex[1]]);
        v2 = Vector(vx[triangle[i].vertex[2]], 
                vy[triangle[i].vertex[2]], 
                vz[triangle[i].vertex[2]]);
        triangle[i].normal= ((v2 - v0) % (v1 - v0)).normalize();
    }
    
    this->neighbor[0]=neighbor[0];
    this->neighbor[1]=neighbor[1];
    this->neighbor[2]=neighbor[2];
    this->neighbor[3]=neighbor[3];
    
    //homogenizeError(&triangle[0]);
    //homogenizeError(&triangle[1]);
    
    lightmap = game->getTexMan()->query(lightmap_name);
}

void LoDQuad::done()
{
    delete[] vx;
    delete[] vy;
    delete[] vz;
    delete[] triangle;
}


void LoDQuad::connect()
{
    if (neighbor[QN_WEST]) {
        triangle[0].neighbor[0] = &neighbor[QN_WEST]->triangle[1];
    } else {
        triangle[0].neighbor[0] = 0;
    }

    if (neighbor[QN_NORTH]) {
        triangle[0].neighbor[1] = &neighbor[QN_NORTH]->triangle[1];
    } else {
        triangle[0].neighbor[1] = 0;
    }

    if (neighbor[QN_EAST]) {
        triangle[1].neighbor[0] = &neighbor[QN_EAST]->triangle[0];
    } else {
        triangle[1].neighbor[0] = 0;
    }

    if (neighbor[QN_SOUTH]) {
        triangle[1].neighbor[1] = &neighbor[QN_SOUTH]->triangle[0];
    } else {
        triangle[1].neighbor[1] = 0;
    }

    triangle[0].neighbor[2] = &triangle[1];
    triangle[1].neighbor[2] = &triangle[0];
}

void LoDQuad::presetup() {
    triangle[0].flags |= TFLAG_ENABLED;
    triangle[1].flags |= TFLAG_ENABLED;
    connect();
}

void LoDQuad::setup(Vector &pos, const float planes[6][4])
{
    evaluator = Evaluator(pos, planes, vx, vy, vz);

    triangle[0].dyn_error = evaluator.evaluate(&triangle[0]);
    triangle[1].dyn_error = evaluator.evaluate(&triangle[1]);
    
    triangle[0].morph = triangle[1].morph = 1.0;
    
    setupRecursive(&triangle[0], pos, 1, MAX_ERROR);
    setupRecursive(&triangle[1], pos, 1, MAX_ERROR);
}

void LoDQuad::draw(JRenderer *renderer)
{
    renderer->setCullMode(JR_CULLMODE_CULL_POSITIVE);
    drawRecursive(renderer,&triangle[0],
            vy[triangle[0].vertex[0]],
            vy[triangle[0].vertex[1]],
            vy[triangle[0].vertex[2]]);
    drawRecursive(renderer,&triangle[1],
            vy[triangle[1].vertex[0]],
            vy[triangle[1].vertex[1]],
            vy[triangle[1].vertex[2]]);
}

void LoDQuad::drawWire(JRenderer *renderer)
{
    renderer->setCullMode(JR_CULLMODE_NO_CULLING);
    BorderSet bdrs_left  = {true, true, true};
    BorderSet bdrs_right = {true, true, false};
    drawWireRecursive(renderer,&triangle[0], bdrs_left);
    drawWireRecursive(renderer,&triangle[1], bdrs_right);
}

// -------------------------- Private methods ---------------------------- //

void LoDQuad::drawRecursive(JRenderer *r, LoDTriangle *tri,
        float y0, float y1, float y2)
{
    if(tri->morph < 0.0 || tri->morph > 1.0) ls_error("\bmorph:%f\n", tri->morph);
    
    int i;
    float y[3];
    y[0] = y0;
    y[1] = y1;
    y[2] = tri->morph * vy[tri->vertex[2]] + (1.0 - tri->morph) * y2;
    
    if (tri->flags & TFLAG_ENABLED) {
#if ENABLE_BIG_TEXTURE
        
        r->setZBufferFunc(JR_ZBFUNC_LEQUAL);
        r->enableSmoothShading();
        r->enableTexturing();
        r->setTexture(main_tex);
        
        r->begin(JR_DRAWMODE_TRIANGLES);
        for (i=0; i<3; i++) {
            Vector color(1,1,1);
            //if (tri->flags & TFLAG_DEBUG) color[1]=0;
            int vtx = tri->vertex[i];
            Vector v( vx[vtx], y[i], vz[vtx]);
            Vector uvw( tex_u[vtx], tex_v[vtx], 0);

            r->setColor(color);
            r->setUVW(uvw);
            r->vertex(v);
        }
        r->end();
#endif
#if ENABLE_NEIGHBOR_DEBUGGING
        ls_message("NEIGHBOR DEBUGGING.\n");
        for(int n=0; n<3; n++) {
            ls_message("neighbor[%d]=%p\n", n, tri->neighbor[n]);
            if (tri->neighbor[0]==tri->neighbor[1]
                    && tri->neighbor[1]==tri->neighbor[2]) {
                ls_warning("All neighbors are equal! %p\n", tri->neighbor[0]);
            }
            if (!tri->neighbor[n]) {
                ls_warning("No neighbor!\n");
                Vector p0 = Vector(
                        vx[tri->vertex[0]],
                        vy[tri->vertex[0]],
                        vz[tri->vertex[0]]);
                Vector p1 = Vector(
                        vx[tri->vertex[1]],
                        vy[tri->vertex[1]],
                        vz[tri->vertex[1]]);
                Vector p2 = Vector(
                        vx[tri->vertex[2]],
                        vy[tri->vertex[2]],
                        vz[tri->vertex[2]]);
                Vector m0 = (p0 + p1 + p2)/3 + Vector(0,1000,0);
                Vector m1;

                switch(n) {
                case 0:
                    m1 = (p0 + p2)/2;
                    break;
                case 1:
                    m1 = (p1 + p2)/2;
                    break;
                case 2:
                    m1 = (p0 + p1)/2;
                    break;
                }

                r->disableTexturing();
                r->begin(JR_DRAWMODE_CONNECTED_LINES);
                r->setColor(Vector(1,0,1));
                r->setAlpha(1);
                *r << m0 << m1;
                r->end();
            } else {
                Vector p0 = (Vector(vx[tri->vertex[0]], vy[tri->vertex[0]], vz[tri->vertex[0]])
                        + Vector(vx[tri->vertex[1]], vy[tri->vertex[1]], vz[tri->vertex[1]])
                        + Vector(vx[tri->vertex[2]], vy[tri->vertex[2]], vz[tri->vertex[2]]))
                        / 3;
                float *vx=this->vx, *vy=this->vy, *vz=this->vz;
                LoDTriangle * nb = tri->neighbor[n];
                if (nb < triangle || nb >= triangle+triangles) {
                    for(int i=0; i<4; i++) {
                        if (neighbor[i] &&
                            nb >= neighbor[i]->triangle &&
                            nb  < neighbor[i]->triangle+neighbor[i]->triangles) {
                            vx = neighbor[i]->vx;
                            vy = neighbor[i]->vy;
                            vz = neighbor[i]->vz;
                            break;
                        }
                    }
                }
                Vector p4 = (Vector(vx[nb->vertex[0]], vy[nb->vertex[0]], vz[nb->vertex[0]])
                        + Vector(vx[nb->vertex[1]], vy[nb->vertex[1]], vz[nb->vertex[1]])
                        + Vector(vx[nb->vertex[2]], vy[nb->vertex[2]], vz[nb->vertex[2]]))
                        / 3;
                ls_message("Neighbor %d is triangle at %p with midpoint at: ",
                        n, nb);
                {
                    Vector p0 = Vector(
                            vx[nb->vertex[0]],
                            vy[nb->vertex[0]],
                            vz[nb->vertex[0]]);
                    Vector p1 = Vector(
                            vx[nb->vertex[1]],
                            vy[nb->vertex[1]],
                            vz[nb->vertex[1]]);
                    Vector p2 = Vector(
                            vx[nb->vertex[2]],
                            vy[nb->vertex[2]],
                            vz[nb->vertex[2]]);
                    p0.dump();
                    p1.dump();
                    p2.dump();
                }
                
                p4.dump();
                Vector p2 = (p0 + p4)/2 +  Vector(0, (p4-p0).length()/2.0 ,0);
                Vector p1 = (p0 + p2)/2;
                Vector p3 = (p2 + p4)/2;

                switch(n) {
                case 0:
                    p3 += Vector(10,20,30);
                    break;
                case 1:
                    p3 += Vector(40,50,60);
                    break;
                case 2:
                    p3 += Vector(70,80,90);
                    break;
                }

                r->disableTexturing();
                r->begin(JR_DRAWMODE_CONNECTED_LINES);
                r->setColor(Vector(n==0,n==1,n==2));
                r->setAlpha(1);
                *r << p0 << p1 << p3 << p4;
                r->end();
            }
        }
#endif
#if ENABLE_DETAIL_TEX
        r->setTexture(detail_tex);
        r->setZBufferFunc(JR_ZBFUNC_EQUAL);
        r->enableAlphaBlending();
        r->begin(JR_DRAWMODE_TRIANGLES);
        for (int x = 2<<(DETAIL_LAYERS-1); x >= 1; x/=2) {
            for (i=0; i<3; i++) {
                v.p.x = vx[ tri->vertex[i] ];
                v.p.y = vy[ tri->vertex[i] ];
                v.p.z = vz[ tri->vertex[i] ];

                v.txt.x=v.p.x * DETAIL_SCALE / (float)x;
                v.txt.y=-v.p.z * DETAIL_SCALE / (float)x;

                r->setAlpha(0.5);
                r->addVertex(&v);
            }
        }
        r->end();
        r->disableAlphaBlending();
        r->setZBufferFunc(JR_ZBFUNC_LEQUAL);
#endif
#if ENABLE_TEXTURING
#   if ENABLE_BIG_TEXTURE
        if ((tri->flags & TFLAG_HAS_CHILDREN)==0) {
#   endif
        drawTexturedTriangle(r, tri, y);
#   if ENABLE_BIG_TEXTURE
        }
#   endif
#endif
#if ENABLE_LIGHTMAP
        r->enableTexturing();
        r->setTexture(lightmap);
        r->setZBufferFunc(JR_ZBFUNC_LEQUAL);
        r->enableAlphaBlending();
        r->setBlendMode(JR_BLENDMODE_MULTIPLICATIVE);
        r->begin(JR_DRAWMODE_TRIANGLES);
        for (i=0; i<3; i++) {
            Vector color(1,1,1);
            int vtx = tri->vertex[i];
            Vector v( vx[vtx], y[i], vz[vtx]);
            Vector uvw( tex_u[vtx], tex_v[vtx], 0);
            r->setColor(color);
            r->setAlpha(1);
            r->setUVW(uvw);
            r->vertex(v);
        }
        r->end();
        r->setBlendMode(JR_BLENDMODE_BLEND);
#endif
    } else {
        float ym = (y[0] + y[1]) / 2.0;
        drawRecursive(r, tri->child[0], y[2], y[0], ym);
        drawRecursive(r, tri->child[1], y[1], y[2], ym);
    }
}

void LoDQuad::drawWireBorder(JRenderer *r, LoDTriangle *tri, int i0, int i1)
{
    jvertex_coltxt v;
    
    v.col.r = 0.0;
    v.col.g = 0.0;
    v.col.b = 0.0;
    
    v.p.x = vx[ tri->vertex[i0] ];
    v.p.y = vy[ tri->vertex[i0] ];
    v.p.z = vz[ tri->vertex[i0] ];
    r->addVertex(&v);

    v.p.x = vx[ tri->vertex[i1] ];
    v.p.y = vy[ tri->vertex[i1] ];
    v.p.z = vz[ tri->vertex[i1] ];
    r->addVertex(&v);
}
    
        
void LoDQuad::drawWireRecursive(JRenderer *r, LoDTriangle *tri, BorderSet bdrs)
{
    int i;
    
    if (tri->flags & TFLAG_ENABLED) {
        r->setVertexMode(JR_VERTEXMODE_GOURAUD);
        
        r->begin(JR_DRAWMODE_LINES);
        
        if (bdrs.left) drawWireBorder(r,tri,0,2);
        if (bdrs.right) drawWireBorder(r,tri,1,2);
        if (bdrs.bottom) drawWireBorder(r,tri,0,1);
        
        r->end();
    } else {
        BorderSet child_bdrs[2];
        
        child_bdrs[0].left = true;
        child_bdrs[0].right = bdrs.bottom;
        child_bdrs[0].bottom = bdrs.left;
        
        child_bdrs[1].right = false;
        child_bdrs[1].left = bdrs.bottom;
        child_bdrs[1].bottom = bdrs.right;
        
        drawWireRecursive(r, tri->child[0], child_bdrs[0]);
        drawWireRecursive(r, tri->child[1], child_bdrs[1]);
    }
}


void LoDQuad::setupBoundingSpheres(LoDTriangle * tri)
{
    if (tri->flags & TFLAG_HAS_CHILDREN) {
        setupBoundingSpheres(tri->child[0]);
        setupBoundingSpheres(tri->child[1]);
        Vector c0(tri->child[0]->bs_center);
        Vector c1(tri->child[1]->bs_center);
        Vector d = (c1 - c0).normalize();
        c0 -= tri->child[0]->radius * d;
        c1 += tri->child[1]->radius * d;
        tri->bs_center = (c0 + c1) / 2.0;
        tri->radius = (c1 - c0).length() / 2.0;
    } else {
        // TODO: compute minimal enclosing Sphere for triangle
        Vector p0(vx[tri->vertex[0]], vy[tri->vertex[0]], vz[tri->vertex[0]]);
        Vector p1(vx[tri->vertex[1]], vy[tri->vertex[1]], vz[tri->vertex[1]]);
        Vector p2(vx[tri->vertex[2]], vy[tri->vertex[2]], vz[tri->vertex[2]]);
        tri->bs_center = (p0 + p1) / 2.0;
        float d1 = (p1 - p0).length()/2.0f;
        float d2 = (p2 - tri->bs_center).length();
        tri->radius = min( d1, d2 );
    }
}

// split2 enables a triangle's children, computes their error value and
// sets their morph factor to the maximum value
void LoDQuad::split2(LoDTriangle *tri)
{
    if (! (tri->flags & TFLAG_HAS_CHILDREN)) {
        ls_warning("Triangle doesn't have children! Aborting!\n");
        return;
    }
    /*ls_message("Splitting triangle %d (%f,%f,%f) (%f,%f,%f) (%f,%f,%f)\n",
        tri_idx,
        
        );*/
    
    // calculate error and morph strength for children
    float error0, error1, morph;
    error0 = evaluator.evaluate(tri->child[0]);
    error1 = evaluator.evaluate(tri->child[1]);
    
    tri->child[0]->dyn_error = error0;
    tri->child[1]->dyn_error = error1;
    
    error0 = max(error0, error1);
    if (error0 > tri->dyn_error) {
        //ls_warning("Error of children(%f) bigger than error of parent(%f)!\n",
        //        error0, tri->dyn_error);
        tri->child[0]->flags |= TFLAG_DEBUG;
        tri->child[1]->flags |= TFLAG_DEBUG;
        error0 = tri->dyn_error;
        tri->child[0]->dyn_error = error0;
        tri->child[1]->dyn_error = error0;
    }
    morph = 1.0 - (MAX_ERROR - error0) / (tri->dyn_error - error0);
    morph = min(1.0f, max(0.0f, morph));
    tri->child[0]->morph = tri->child[1]->morph = morph;
    
    tri->flags &= (0xffffffff ^ TFLAG_ENABLED);
    tri->child[0]->flags |= TFLAG_ENABLED;
    tri->child[1]->flags |= TFLAG_ENABLED;
    
    tri->child[LEFT]->neighbor[BOTTOM] = tri->neighbor[LEFT];
    tri->child[RIGHT]->neighbor[BOTTOM] = tri->neighbor[RIGHT];
    
    tri->child[LEFT]->neighbor[LEFT] = tri->child[RIGHT];
    tri->child[RIGHT]->neighbor[RIGHT] = tri->child[LEFT];
    
    if (tri->neighbor[LEFT]) {
        if (tri == tri->neighbor[LEFT]->neighbor[BOTTOM] ) {
            tri->neighbor[LEFT]->neighbor[BOTTOM] = tri->child[LEFT];
        } else if (tri == tri->neighbor[LEFT]->neighbor[RIGHT] ) {
            tri->neighbor[LEFT]->neighbor[RIGHT] = tri->child[LEFT];
        } else {
            tri->neighbor[LEFT]->neighbor[LEFT] = tri->child[LEFT];
        }
    }
    
    if (tri->neighbor[RIGHT]) {
        if (tri == tri->neighbor[RIGHT]->neighbor[BOTTOM] ) {
            tri->neighbor[RIGHT]->neighbor[BOTTOM] = tri->child[RIGHT];
        } else if (tri == tri->neighbor[RIGHT]->neighbor[RIGHT] ) {
            tri->neighbor[RIGHT]->neighbor[RIGHT] = tri->child[RIGHT];
        } else {
            tri->neighbor[RIGHT]->neighbor[LEFT] = tri->child[RIGHT];
        }
    }
}

void LoDQuad::split(LoDTriangle *tri)
{
    // Don't split triangles that have already been split
    if ((tri->flags & TFLAG_ENABLED) == 0) {
        ls_error("Trying to split triangle@%p which has already been split!\n",
                tri);
        return;
    }
    
    if (tri->neighbor[BOTTOM]) {
        if (tri != tri->neighbor[BOTTOM]->neighbor[BOTTOM]) {
            split(tri->neighbor[BOTTOM]);
        }
        // Now we have a diamond configuration:
        //    /\
        //   /__\  <- our triangle tri
        //   \  /  <- tri->neighbor[BOTTOM]
        //    \/
        split2(tri);
        split2(tri->neighbor[BOTTOM]);
        
        // Make sure the diamond has a uniform morph value in all four
        // triangles. Since split2 gives the two children of a triangle already
        // a uniform morph value, we just have to find which triangle's
        // children have the bigger value and then copy it to the other
        // triangle's children.
        if (tri->child[0]->morph > tri->neighbor[BOTTOM]->child[0]->morph) {
            tri->neighbor[BOTTOM]->child[0]->morph =
                    tri->neighbor[BOTTOM]->child[1]->morph =
                    tri->child[0]->morph;
        } else {
            tri->child[0]->morph = tri->child[1]->morph =
                    tri->neighbor[BOTTOM]->child[0]->morph;
        }
        
        tri->child[LEFT]->neighbor[RIGHT]=
            tri->neighbor[BOTTOM]->child[RIGHT];
        tri->child[RIGHT]->neighbor[LEFT]=
            tri->neighbor[BOTTOM]->child[LEFT];
        tri->neighbor[BOTTOM]->child[LEFT]->neighbor[RIGHT]=
            tri->child[RIGHT];
        tri->neighbor[BOTTOM]->child[RIGHT]->neighbor[LEFT]=
            tri->child[LEFT];
    } else {
        split2(tri);
        tri->child[LEFT]->neighbor[RIGHT]=0;
        tri->child[RIGHT]->neighbor[LEFT]=0;
    }
}


LoDQuad::Evaluator::Evaluator(const Vector & p, const float plane[6][4],
        const float * vx, const float * vy, const float * vz)
: pos(p), vx(vx), vy(vy), vz(vz)
{
    for(int i=0; i<6; i++) for (int j=0; j<4; j++)
        this->plane[i][j] = plane[i][j];
}

float LoDQuad::Evaluator::evaluate(LoDTriangle * tri)
{
    float error=tri->error;
    float dist=calcDistance(tri->bs_center, plane[PLANE_MINUS_Z]);

    if (error < MAX_ERROR) error = MAX_ERROR;
#if USE_Z_METRIC
    error = error *
        (ERROR_FACTOR*ERROR_FACTOR) /
        (dist*dist);
#endif
    
#if USE_BOUNDING_SPHERE_METRIC
    {
        float dist2 = max(0.0001f, dist - tri->radius);
        error *= (ERROR_FACTOR*ERROR_FACTOR) / (dist2*dist2);
    }
#endif

#if USE_BOUNDING_SPHERE_DISTANCE_METRIC
    {
        float dist2 = (tri->bs_center-pos).length() - tri->radius;
        dist2 = max(0.0001f, dist2);
        //error *= (ERROR_FACTOR*ERROR_FACTOR*ERROR_FACTOR) / (dist2*dist2*dist2);
        error *= (ERROR_FACTOR*ERROR_FACTOR) / (dist2*dist2);
        //error *= (ERROR_FACTOR) / (dist2);
    }
#endif

#if USE_DISTANCE_METRIC
    {
        Vector c0(vx[tri->vertex[0]], vy[tri->vertex[0]], vz[tri->vertex[0]]);
        Vector c1(vx[tri->vertex[1]], vy[tri->vertex[1]], vz[tri->vertex[1]]);
        Vector c2(vx[tri->vertex[2]], vy[tri->vertex[2]], vz[tri->vertex[2]]);
        Vector c2c0 = c0 - c2;
        Vector c2c1 = c1 - c2;
        Vector c2pos = pos - c2;
        float a = (c2c0 * c2pos) / (c2c0.lengthSquare());
        float b = (c2c1 * c2pos) / (c2c1.lengthSquare());
        float dist2;
        if (a>=0 && b>=0 && a+b<=1) { // over triangle
            dist2 = ((pos-c0) * tri->normal);
        } else {
            float d0 = (pos-c0).length();
            float d1 = (pos-c1).length();
            float d2 = (pos-c2).length();
            dist2 = min( min(d0,d1), d2 );
        }
        //float dist2 = (Vector(vx[tri->vertex[2]], vy[tri->vertex[2]], vz[tri->vertex[2]])
        //    - pos).length();
        error = error *
            (ERROR_FACTOR*ERROR_FACTOR) /
            (dist2 * dist2);
    }
#endif

#if USE_ANGULAR_METRIC
    // We take into account that the error is perceived as smaller if
    // we look onto a triangle directly from top
    Vector v0(vx[tri->vertex[0]],
            vy[tri->vertex[0]],
            vz[tri->vertex[0]]);
    float scalar_prod = pow(abs(tri->normal * (v0 - pos).normalize()), 0.01);

    error *= scalar_prod;
    //ls_error("scalar_prod: %f\n", scalar_prod);

#endif

#if USE_EDGE_METRIC
    // Lets give highly visible edges more detail
    {
        Vector v(vx[tri->vertex[2]],vy[tri->vertex[2]],vz[tri->vertex[2]]);
        v-=pos;
        if (v * tri->normal < 0) {
            for(int i=0; i<3; i++) {
                if (tri->neighbor[i]) {
                    LoDTriangle * n = tri->neighbor[i];
                    v = Vector(
                            vx[n->vertex[2]],
                            vy[n->vertex[2]],
                            vz[n->vertex[2]]);
                    v-=pos;
                    if( v * tri->neighbor[i]->normal > 0)
                    {
                        error *= 3.0;
                        tri->flags |= TFLAG_DEBUG;
                        break;
                    }
                }
            }
        }
    }
#endif // USE_EDGE_METRIC
    return error;
}

LoDQuad::Evaluator::FrustumView
LoDQuad::Evaluator::checkAgainstFrustum( const LoDTriangle * tri )
{
    float dist;
    int out_partially_flags = 0;
    /*
      We iterate through the 6 view planes, the "minus-z"-plane
      comes last. This way we can just reuse the calculated dist
      for the level of detail calculations.
    */
    for (int i=5; i >= 0; i--) {
        dist=calcDistance(tri->bs_center, plane[i]);
        if (dist < tri->radius) {
            out_partially_flags |= 2 << i;
        }
        if (dist < -tri->radius) return OUTSIDE;
    }

    if (out_partially_flags == 0) {
        // the sphere lies completely inside the viewing frustum
        // so we won't need any further checks for the child triangles
        return INSIDE;
    }
    return PARTIAL;
}

float LoDQuad::Evaluator::calcDistance(const Vector & point, const float *plane)
{
    return
        point[0]*plane[0] +
        point[1]*plane[1] +
        point[2]*plane[2] +
        plane[3];
}


#define OUTMASK_MINUS_X  ( 2 << PLANE_MINUS_X )
#define OUTMASK_PLUS_X   ( 2 << PLANE_PLUS_X  )
#define OUTMASK_MINUS_Y  ( 2 << PLANE_MINUS_Y )
#define OUTMASK_PLUS_Y   ( 2 << PLANE_PLUS_Y  )
#define OUTMASK_MINUS_Z  ( 2 << PLANE_MINUS_Z )
#define OUTMASK_PLUS_Z   ( 2 << PLANE_PLUS_Z  )


void LoDQuad::setupRecursive
    (LoDTriangle *tri,
     Vector &pos,
     int partially_obscured,
     float parent_error)
{
#ifdef ENABLE_DYNAMIC_LOD
    float error;
    Evaluator::FrustumView frustum_view;
    
    if ((tri->flags & TFLAG_ENABLED) == 0) {
        setupRecursive(tri->child[0], pos, 1, tri->dyn_error);
        setupRecursive(tri->child[1], pos, 1, tri->dyn_error);
        
        //tri->morph = 0;
        //setupRecursive(tri->child[0], pos, 1, MAX_ERROR);
        //setupRecursive(tri->child[1], pos, 1, MAX_ERROR);
        
    } else {
        if (partially_obscured) {
            frustum_view = evaluator.checkAgainstFrustum(tri);
            partially_obscured = (frustum_view == Evaluator::PARTIAL);
        } else {
            frustum_view = Evaluator::INSIDE;
        }
        
        /*
        We clear the TFLAG_DETAIL_TEX which might still be set from the
        previous setup.
        If the distance from the viewer to the triangle is near enough
        it gets set again later.
        We also clear TFLAG_DEBUG.
        */
        tri->flags &= ~TFLAG_DETAIL_TEX;
        tri->flags &= ~TFLAG_DEBUG;
        
        if (frustum_view == Evaluator::OUTSIDE) {
            tri->flags |= TFLAG_ENABLED;
            tri->flags |= TFLAG_DEBUG;
        } else {

            error = tri->dyn_error;
            //ls_message("error: %f\n", error);
            //if (error < 0) error = 1000000.0;

            if ((error > MAX_ERROR) &&
                ((tri->flags & TFLAG_HAS_CHILDREN) != 0))
            {
                split(tri);
                //tri->morph = 1;
                setupRecursive(tri->child[0], pos, partially_obscured, error);
                setupRecursive(tri->child[1], pos, partially_obscured, error);
            } else {
                //tri->morph = 1.0 - (MAX_ERROR - error) / (parent_error - error);
                //ls_message("MAX_ERROR=%7.5f parent_error=%7.5f error=%7.5f"
                //        " morph=%7.5f\n",
                //        MAX_ERROR, parent_error, error, tri->morph);
                //tri->morph = min(1.0f, max(0.0f, tri->morph));
                tri->flags |= TFLAG_ENABLED;
                //if ( dist < DETAIL_TEX_MAX_RANGE ) {
                //    tri->flags |= TFLAG_DETAIL_TEX;
                //}
            }
            
        }
    
    }
#else // ENABLE_DYNAMIC_LOD
    if (tri->flags & TFLAG_HAS_CHILDREN) {
        if (tri->flags & TFLAG_ENABLED) {
            split(tri);
        }
        setupRecursive(tri->child[0], pos, plane,1);
        setupRecursive(tri->child[1], pos, plane,1);
    }
    
    /*
    if (tri->flags & TFLAG_HAS_CHILDREN) {
        tri->flags &= 0xffffffff ^ TFLAG_ENABLED;
        setupRecursive(tri->child[0], plane);
        setupRecursive(tri->child[1], plane);
    } else tri->flags |= TFLAG_ENABLED;
    */

#endif
}

LoDQuad::CoordRel LoDQuad::getCoordRelX(float x)
{
    float vmin, vmax;
    
    vmin = vx[triangle[0].vertex[0]];
    vmax = vx[triangle[0].vertex[1]];
    
    if (x < vmin) return BELOW;
    else if (x > vmax) return ABOVE;
    else return INSIDE;
}

LoDQuad::CoordRel LoDQuad::getCoordRelZ(float z)
{
    float vmin, vmax;
    
    vmin = vz[triangle[0].vertex[0]];
    vmax = vz[triangle[0].vertex[1]];
    
    if (z < vmin) return BELOW;
    else if (z > vmax) return ABOVE;
    else return INSIDE;
}

float LoDQuad::getHeightAt(float x, float z)
{
    float height;
    getHeightAtTriangle(&triangle[0], x, z, &height)
            || getHeightAtTriangle(&triangle[1], x, z, &height);
    return height;
}


#define VSCALAR(x1,y1,x2,y2) ((x1)*(x2)+(y1)*(y2))
// Returns false if (x/z) is not inside
// Our triangle looks like this:
//             2 p2
//        v2,-'\
//      2,-'    \ 1 v1
//    ,-'        \
// 0 -------------- 1
// p0      0 v0     p1

bool LoDQuad::getHeightAtTriangle(LoDTriangle *tri, float x, float z, float *height)
{
    float px[3], py[3], pz[3]; // the triangle corners
    float vx[3], vz[3];        // Direction vectors of the tri edges
    float nx[3], nz[3];        // Normal vectors of the tri edges
    float d[3];                // Distance of (x,z) to the according edge
    float dp[3];               // Distance of a corner point to the opposing edge
    bool all_positive;
    // Copy the triangle corner points
    for(int i=0; i<3; i++) {
        px[i]=this->vx[tri->vertex[i]];
        py[i]=this->vy[tri->vertex[i]];
        pz[i]=this->vz[tri->vertex[i]];
        //ls_warning("px[%d] = %f\tpz[%d] = %f\n", i, px[i], i, pz[i]);
    }
    
    // Calculate the edge direction vectors
    for(int i=0; i<3; i++) {
        vx[i] = px[(i+1)%3] - px[i];
        vz[i] = pz[(i+1)%3] - pz[i];
        //ls_message("vx[%d] = %f\tvz[%d] = %f\n", i, vx[i], i, vz[i]);
    }
    
    // Calculate the edge normals. They should point towards the triangle.
    // Our triangles are counter-clockwise (LEFT, RIGHT, TOP)
    // So our normals should be the direction vectors rotated counter-clockwise
    // By 90 degrees
    for (int i=0; i<3; i++) {
        nx[i] = -vz[i];
        nz[i] =  vx[i];
    }
    
    // Calculate the distance between (x,z) to every edge. This need not be
    // normalized because at this time we are just interested in the sign of
    // the distance.
    all_positive=true;
    for (int i=0; i<3; i++) {
        d[i] = VSCALAR(nx[i], nz[i], x-px[i], z-pz[i]);
        if (d[i]<0) all_positive=false;
    }
    
    //ls_error("d: [%f, %f, %f]\n", d[0], d[1], d[2]);
    
    // If not all edge distances are positive, we are done, because the point
    // Is not inside this triangle
    if (!all_positive) return false;
    
    // Now, if the triangle has children, pass the test to them. Else, we have
    // to calculate the interpolated y value (height) of the tri at (x,z)
    if (tri->flags & TFLAG_HAS_CHILDREN) {
        return getHeightAtTriangle(tri->child[0], x, z, height)
                || getHeightAtTriangle(tri->child[1], x, z, height);
    } else {
        dp[1] = VSCALAR(nx[2], nz[2], px[1]-px[2], pz[1]-pz[2]);
        dp[0] = VSCALAR(nx[1], nz[1], px[0]-px[2], pz[0]-pz[2]);
        *height = py[2]
                + ((py[1] - py[2]) * d[2]) / dp[1]
                + ((py[0] - py[2]) * d[1]) / dp[0];
        return true;
    }
}


#define HOMOGENIZE_DELTA 500.0f

float LoDQuad::homogenizeError(LoDTriangle * tri) {
    if (tri->flags & TFLAG_HAS_CHILDREN) {
        tri->error = max( tri->error,
                HOMOGENIZE_DELTA + max(homogenizeError(tri->child[0]),
                homogenizeError(tri->child[0])));
        return tri->error;
    } else return tri->error;
}

// #define EPSILON 0.01
// #define MAX_INTERVAL_SQUARE 100000.0
// bool LoDQuad::lineCollides(Vector a, Vector b, Vector * x, LoDTriangle * tri)
// {
//     float h_a = getHeightAt(a[0], a[2]);
//     float h_b = getHeightAt(b[0], b[2]);
//     
//     if (h_a >= a[1]) {
//         *x=a;
//         return true;
//     }
//     
//     if ((a-b).lengthSquare() > MAX_INTERVAL_SQUARE) {
//         return lineCollides(a, (a+b)/2.0, x) || lineCollides((a+b)/2.0, b, x);
//     }
//      
//     if (h_a < a[1] && h_b < b[1]) return false;
//     
//     float delta = (a-b).length();
//     while(delta >= EPSILON) {
//         Vector m = (a + b) / 2;
//         float h_m = getHeightAt(m[0], m[2]);
//         if (h_a >= a[1]) {
//             if (h_m >= m[1]) {
//                 a = m;
//                 h_a = h_m;
//             } else {
//                 b = m;
//                 h_b = h_m;
//             }
//         } else {
//             if (h_m >= m[1]) {
//                 b = m;
//                 h_b = h_m;
//             } else {
//                 a = m;
//                 h_a = h_m;
//             }
//         }
//         delta /= 2;
//     }
//     
//     *x = a;
//     return true;
// }

bool LoDQuad::lineCollides(Vector a, Vector b, float * t, LoDTriangle * tri)
{
    float t0, t1;
    
    //ls_message("Checking for collision in tri %p from ", tri);
    //a.dump();
    //ls_message("to ");
    //b.dump();
    
    // bounding sphere test
    if (!Collide::points((a+b)/2, tri->bs_center,
            ((a-b)/2).length(), tri->radius)) return false;
    if (!Collide::movingPoints(
            Line::Between(a,b),
            Line::Between(tri->bs_center, tri->bs_center),
            0.0, tri->radius,
            &t0, &t1)) {
        return false;
    }
    if ( t1 < 0  || t0 > 1) return false;
    *t = t0;
    
    if (tri->flags & TFLAG_HAS_CHILDREN) {
        t0 = max(0.0f, t0);
        t1 = min(1.0f, t1);
        Vector d = b-a;
        bool c0, c1;
        c0 = lineCollides(a, b, &t0, tri->child[0]);
        c1 = lineCollides(a, b, &t1, tri->child[1]);
        if (c0 && c1) {
            *t = min(t0, t1);
            return true;
        } else if (c0) {
            *t = t0;
            return true;
        } else if (c1) {
            *t = t1;
            return true;
        } else return false;
    }
    
    // plane collision test
    Vector p0( vx[tri->vertex[0]], vy[tri->vertex[0]], vz[tri->vertex[0]]);
    Vector p1( vx[tri->vertex[1]], vy[tri->vertex[1]], vz[tri->vertex[1]]);
    Vector p2( vx[tri->vertex[2]], vy[tri->vertex[2]], vz[tri->vertex[2]]);
    if (!Collide::lineOnPlane(Line::Between(a,b), Plane(p0,p2,p1), t)) {
        return false;
    }
    // t has to be between 0 and 1, otherwise found point is not on [ab]
    if (*t < 0 || *t > 1) return false;
    
    // triangle intersection test via conversion into baricentric coordinates
    Vector x = a + (*t) * (b-a) - p2;
    Vector d1 = p0 - p2;
    Vector d2 = p1 - p2;
    float ta = (x*d1) / d1.lengthSquare();
    float tb = (x*d2) / d2.lengthSquare();
    if ( ta>=0 && tb>=0 && ta+tb<=1 ) {
        //ls_warning("hit!");
        //x.dump();
        return true;
    }
    else return false;
}

void LoDQuad::drawTexturedTriangle(JRenderer * r, LoDTriangle * tri, float * y)
{
    int tex_indices[3];
    for (int i=0; i<3; i++) {
        int u = (int) ( tex_u[tri->vertex[i]] * 512.0 );
        int v = (int) ( tex_v[tri->vertex[i]] * 512.0 );
        u = min(u, 511);
        v = min(v, 511);
        tex_indices[i] = texmap->pixelAt(u,v);
    }
    int max_index = max(tex_indices[0], max(tex_indices[1], tex_indices[2]));
    int absolute_max = max_index;
    
    Vector uvw[3];
    for(int i=0; i<3; i++) {
        uvw[i][0] = tex_u[tri->vertex[i]] * 128;
        uvw[i][1] = tex_v[tri->vertex[i]] * 128;
    }
    
    Vector v[3];
    for(int i=0; i<3; i++) {
        v[i] = Vector(vx[tri->vertex[i]], y[i], vz[tri->vertex[i]]);
    }
    
    r->enableAlphaBlending();
    r->enableTexturing();
    
    while ( max_index != -1 ) {
        TexPtr tex = textures[max_index];
        r->setTexture(tex);
        r->begin(JR_DRAWMODE_TRIANGLES);
        for (int i=0; i<3; i++) {
            r->setColor(Vector(1,1,1));
            r->setUVW(uvw[i]);
#if ENABLE_BIG_TEXTURE
            //r->setAlpha(tex_indices[i]==max_index);
            r->setAlpha(tri->morph * (float) (tex_indices[i] == max_index));
#else
            if (max_index != absolute_max) {
                if (i==2) {
                    if (tex_indices[i]==max_index) r->setAlpha(tri->morph);
                    else r->setAlpha(0);
                } else r->setAlpha(tex_indices[i]==max_index);
            } else r->setAlpha(1);
#endif
            r->vertex(v[i]);
        }
        r->end();
        
        int next_max = -1;
        for(int i=0; i<3; i++) {
            int tex_index = tex_indices[i];
            if (tex_index < max_index && tex_index > next_max)  {
                next_max = tex_index;
            }
        }
        max_index = next_max;
    }
    
    r->disableAlphaBlending();
}
        
    

// BEGIN: LoDQuadManager methods

LoDQuadManager::LoDQuadManager(IGame *the_game)
{
    int        u,v;
    char       buf[256];
    ifstream   in;
    LoDQuad*   (neighbor[4]);
    TexPtr     main_tex;
    TexPtr     detail_tex;
    JSprite    spr;

    string terrain_prefix;
    string texture_prefix;
    string texmap_prefix;
    string lightmap_prefix;
    int quads_w;
    int quads_h;
    string detail_tex_name;
        
    game=the_game;
    cfg = Ptr<IConfig>();
    cfg    = game->getConfig();
    camera = game->getCamera();
    renderer = game->getRenderer();
    
    // Get the terrain and texture paths from the config
    terrain_prefix=cfg->query("LoDQuadManager_terrain_prefix");
    texture_prefix=cfg->query("LoDQuadManager_texture_prefix");
    detail_tex_name=cfg->query("LoDQuadManager_detail_tex_name");
    texmap_prefix=cfg->query("LoDQuadManager_texmap_prefix");
    lightmap_prefix=cfg->query("LoDQuadManager_lightmap_prefix");
    
    // Get the texture grid size from the config
    quads_w=atoi(cfg->query("LoDQuadManager_quads_w"));
    quads_h=atoi(cfg->query("LoDQuadManager_quads_h"));
    
    // First load the detail texture
    detail_tex = game->getTexMan()->query(
            detail_tex_name.c_str(), JR_HINT_GREYSCALE, 0, true);
    
    width=quads_w;
    height=quads_h;
    quad=new LoDQuad[width*height];
    
    for (v=0; v<height; v++) {
        for (u=0; u<width; u++) {
            if (v>0) {
                neighbor[QN_NORTH]=&quad[(v-1)*width + u];
            } else {
                neighbor[QN_NORTH]=0;
            }
            
            if (v<(height-1)) {
                neighbor[QN_SOUTH]=&quad[(v+1)*width + u];
            } else {
                neighbor[QN_SOUTH]=0;
            }
            
            if (u>0) {
                neighbor[QN_WEST]=&quad[v*width + u-1];
            } else {
                neighbor[QN_WEST]=0;
            }
            
            if (u<(width-1)) {
                neighbor[QN_EAST]=&quad[v*width + u+1];
            } else {
                neighbor[QN_EAST]=0;
            }
            
            // DEBUG: set neighbors to zero and see if Landscape still crashes
            //neighbor[QN_NORTH]=0;
            //neighbor[QN_SOUTH]=0;
            //neighbor[QN_EAST]=0;
            //neighbor[QN_WEST]=0;
            
            sprintf(buf,"%s-%d-%d.spr", texture_prefix.c_str(), u, v);
            main_tex = game->getTexMan()->query(
                    buf, JR_HINT_FULLOPACITY, 0, true);
            
            sprintf(buf,"%s-%d-%d.qad", terrain_prefix.c_str(), u, v);
            in.open(buf);
            if (!in) ls_error("LoDTerrain: Couldn't open %s\n", buf);
            sprintf(buf,"%s-%d-%d.tga", texmap_prefix.c_str(), u, v);
            char lbuf[256];
            sprintf(lbuf, "%s-%d-%d.spr", lightmap_prefix.c_str(), u, v);
            quad[v*width + u].init(the_game, in, neighbor, main_tex,
                    detail_tex, buf, textures, lbuf);
            in.close();
        }
    }

    counter=0;
    
    game->getKeyboardRemapper()->map("debug",
            SigC::slot(this, &LoDQuadManager::toggleDebugMode));
    debug_mode = false;
    
    loadTextures();
}

LoDQuadManager::~LoDQuadManager()
{
    for (int i=0; i<(width*height); i++) {
        quad[i].done();
    }
    delete[] quad;
}

void LoDQuadManager::toggleDebugMode()
{
    debug_mode = !debug_mode;
}

// Begin: IDrawable method
void LoDQuadManager::draw()
{
    int i;
    float planes[6][4];
    float pos_a[3];
    
    camera->getFrustumPlanes(planes);
    camera->getLocation(pos_a);
    Vector pos(pos_a);
    
    for (i=0; i<(width*height); i++) {
        quad[i].presetup();
    }
    for (i=0; i<(width*height); i++) {
        quad[i].setup(pos, planes);
    }
    for (i=0; i<(width*height); i++) {
        quad[i].draw(renderer);
        if (debug_mode) quad[i].drawWire(renderer);
    }
    counter++;
}


// BEGIN: ITerrain method
float LoDQuadManager::getHeightAt(float x, float z)
{
    LoDQuad *q = getQuadAtPoint(x,z);
    if (q) {
        return q->getHeightAt(x,z);
    } else return 0.0;
}

namespace {
    // next_edge assumes that (px,py) is contained in the rectangle (x,y,w,h).
    // Then it tries to walk from there in direction (vx, vy) until it hits an
    // edge of the rectangle. Then it returns true and sets t to the parameter that
    // it found: (px, py) + t*(vx,vy) lies on an edge
    // If it can't hit an edge (since vx and vy are zero) it returns false.
    
    bool next_edge( float x, float y, float w, float h,
            float px, float py, float vx, float vy, float *t )
    {
        if (vx!=0 && vy!=0) {
            float tx = (x - px) / vx;
            if (tx < 0) tx = (x + w - px) / vx;
            float ty = (y - py) / vy;
            if (ty < 0) ty = (y + h - py) / vy;
            *t = min(tx, ty);
            return true;
        } else if ( vx!=0 ) {
            float tx = (x - px) / vx;
            if (tx < 0) tx = (x + w - px) / vx;
            *t = tx;
            return true;
        } else if ( vy!=0 ) {
            float ty = (y - py) / vy;
            if (ty < 0) ty = (y + h - py) / vy;
            *t = ty;
            return true;
        } else return false;
    }
}

// lineCollides tests whether an object going from a to b hits the terrain and
// returns the point where this happens
        
// bool LoDQuadManager::lineCollides(Vector a, Vector b, Vector * cx) {
//     LoDQuad *quad = getQuadAtPoint(a[0], a[2]);
//     
//     if (!quad) return false;
//     
//     float x = quad->vx[quad->triangle[0].vertex[2]];
//     float z = quad->vz[quad->triangle[0].vertex[2]];
//     float w = quad->vx[quad->triangle[1].vertex[2]] - x;
//     float h = quad->vz[quad->triangle[1].vertex[2]] - z;
//     
//     Vector d = (b-a);
//     
//     float t;
//     
//     Vector p0;
//     Vector p1 = a;
//     Vector m = p1;
//     for( ; ; ) { // Exits via return
//         if (!next_edge( x, z, w, h, m[0], m[2], d[0], d[2], &t)) return false;
//         p0 = p1;
//         p1 += t * d;
//         
//         if (((p0-a)*d) / d.lengthSquare() >= 1) return false;
//         if (((p1-a)*d) / d.lengthSquare() > 1) p1 = a+d;
//         
//         m = (p1 + p0)/2;
//         quad = getQuadAtPoint(m[0], m[2]);
//         if (quad) {
//             float t0, t1;
//             bool c0, c1;
//             c0 = quad->lineCollides(p0, p1, &t0, &quad->triangle[0]);
//             c1 = quad->lineCollides(p0, p1, &t1, &quad->triangle[1]);
//             if (c0 || c1) {
//                 if (c0 && c1) t = min(t0, t1);
//                 else if (c0) t = t0;
//                 else t = t1;
//                 *cx = p0 + t*(p1-p0);
//             }
//         } else return false;
//         x = quad->vx[quad->triangle[0].vertex[2]];
//         z = quad->vz[quad->triangle[0].vertex[2]];
//     }
// }

bool LoDQuadManager::lineCollides(Vector a, Vector b, Vector * cx) {
    float t;
    static int count = 0;
    //ls_message("lineCollide for the %dth time.\n", ++count);
    LoDQuad * quad = getQuadAtPoint(a[0], a[2]);
    if (!quad) return false;
    if (quad->lineCollides(a,b, &t, &quad->triangle[0]) ||
        quad->lineCollides(a,b, &t, &quad->triangle[1])) {
        *cx = a + (b-a)*t;
        //game->drawDebugTriangleAt(*cx);
        return true;
    }
}
    

// Returns the quad that lies under the given X/Z-Pair.
// Returns 0 if there is none
LoDQuad * LoDQuadManager::getQuadAtPoint(float x, float z)
{
    // northwest point of landscape
    float qx=quad[0].vx[quad[0].triangle[0].vertex[2]];
    float qz=quad[0].vz[quad[0].triangle[0].vertex[2]];
    // tile width and length
    float dx=quad[0].vx[quad[0].triangle[0].vertex[1]] - qx;
    float dz=quad[0].vz[quad[0].triangle[0].vertex[0]] - qz;
    
    float uf = (x - qx) / dx;
    float vf = (z - qz) / dz;
    int u = (int)uf;
    int v = (int)vf;
    
    if ((u>=0)&&(u<width)&&(v>=0)&&(v<height)) {
        int idx = v*width + u;
        return &quad[idx];
    } else return 0;
}


void LoDQuadManager::loadTextures()
{
    char * names[] = {"ice.spr", "forest.spr", "desert.spr", "grass.spr",
            "darkrock.spr", "mediumrock.spr", "rock.spr",
            "water.spr", "water.spr", "water.spr", 0};
    
    string basename = cfg->query("LoDQuadManager_tile_dir");
    for (int i=0; i<256 && names[i]; i++) {
        textures[i] = game->getTexMan()->
                query(
                    (basename + "/" + names[i]).c_str(),
                    JR_HINT_FULLOPACITY
                );
    }
}

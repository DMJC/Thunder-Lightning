#include "player.h"
#include <sigc++/bind.h>

#define MIN_HEIGHT_ABOVE_GROUND 3.0f
#define MAX_ROLL_ANGLE 1.3090f
#define MAX_ROLL_SPEED 1.5f
#define MAX_MOUSE_MOVE 50.0f
#define MAX_TURN_PER_SECOND 1.0472f
#define MOUSE_SENSITIVITY 0.002f
#define MAX_PITCH_ANGLE 0.6109f
#define STRIFE_SPEED 300.0f

Player::Player(IGame *thegame)
{
    this->thegame=thegame;
    renderer=thegame->getRenderer();
    terrain=thegame->getTerrain();
    
    strife.forward=false;
    strife.backward=false;
    strife.left=false;
    strife.right=false;

    speed=0.0f;
    position.point.y=INITIAL_ALTITUDE;
    position.point.x=0.0f;
    position.point.z=0.0f;
    roll=0.0f;
    
    KeyboardRemapper *r=thegame->getKeyboardRemapper();
    r->map("+forward", SigC::bind( 
            SigC::slot(this, & Player::strifeForward), true));
    r->map("-forward", SigC::bind( 
            SigC::slot(this, & Player::strifeForward), false));
    r->map("+backward", SigC::bind( 
            SigC::slot(this, & Player::strifeBackward), true));
    r->map("-backward", SigC::bind( 
            SigC::slot(this, & Player::strifeBackward), false));
    r->map("+left", SigC::bind( 
            SigC::slot(this, & Player::strifeLeft), true));
    r->map("-left", SigC::bind( 
            SigC::slot(this, & Player::strifeLeft), false));
    r->map("+right", SigC::bind( 
            SigC::slot(this, & Player::strifeRight), true));
    r->map("-right", SigC::bind( 
            SigC::slot(this, & Player::strifeRight), false));

}

void Player::action()
{
    doFlight();
    /*ls_message("Player position: x=%f y=%f z=%f. Speed=%f\n",
           position.point.x,position.point.y,position.point.z,speed);*/
}

void Player::getCamera(JCamera *camera)
{
    JMatrix m1,m2,m3;
    m1.init();
    m1.translate(-position.point.x,
                 -position.point.y,
                 -position.point.z);
    m2.initRotateY(-rotation.point.y);
    m3.initMultiplyBA(&m1.matrix,&m2.matrix);

    m1.initRotateX(-rotation.point.x);
    m2.initMultiplyBA(&m3.matrix,&m1.matrix);
    
    m1.initRotateZ(-rotation.point.z);
    m3.initMultiplyBA(&m2.matrix,&m1.matrix);

    camera->cam.matrix=m3.matrix;
    camera->cam.focus=0.8f;
}

void Player::getPosition(jpoint_t *position)
{
    *position=this->position.point;
}

void Player::getViewVec(jpoint_t *viewvec)
{
    JPoint point(0.0f,0.0f,1.0f);
    point.rotateX(rotation.point.x);
    point.rotateY(rotation.point.y);
    *viewvec=point.point;
}

#define PER_SECOND(x,t) ((x)*(t)/1000.0)

void Player::doFlight()
{
    int buttons;
    float mx,my;
    double timedelta=thegame->getTimeDelta();
    JPoint viewvec;
    double terrain_height;

    thegame->getMouseState(&mx,&my,&buttons);

    if (mx > MAX_MOUSE_MOVE) {
        //mx=MAX_MOUSE_MOVE;
    }
    if (mx < -MAX_MOUSE_MOVE) {
        //mx=-MAX_MOUSE_MOVE;
    }

    roll-=PER_SECOND(mx/MAX_MOUSE_MOVE*MAX_ROLL_SPEED,timedelta);

    if (roll > MAX_ROLL_ANGLE) {
        roll=MAX_ROLL_ANGLE;
    }
    if (roll < -MAX_ROLL_ANGLE) {
        roll=-MAX_ROLL_ANGLE;
    }
    
    rotation.add((float) -my * MOUSE_SENSITIVITY,
                 - PER_SECOND(sin(roll/MAX_ROLL_ANGLE*1.5708)*MAX_TURN_PER_SECOND,
                              timedelta),
                0.0f);
    rotation.point.z=roll;

    if (rotation.point.x>MAX_PITCH_ANGLE) {
        rotation.point.x=MAX_PITCH_ANGLE;
    }
    if (rotation.point.x<-MAX_PITCH_ANGLE) {
        rotation.point.x=-MAX_PITCH_ANGLE;
    }
    
    if (buttons&JMOUSE_BUTTON3) {
        speed+=5.0f;
    }
    if (buttons&JMOUSE_BUTTON1) {
        speed-=5.0f;
    }

    float front[3], right[3];
    getOrientation(front, right);
    Vector v = (timedelta/1000.0)*getStrifeVector(Vector(front), Vector(right));
    
    getViewVec(&viewvec.point);
    viewvec.scale(PER_SECOND(speed, timedelta));
    position.add(&viewvec.point);
    position.add(v[0], v[1], v[2]);

    terrain_height=terrain->getHeightAt(
            position.point.x, position.point.z);

    if (position.point.y < (terrain_height + MIN_HEIGHT_ABOVE_GROUND)) {
        position.point.y=terrain_height+MIN_HEIGHT_ABOVE_GROUND;
    }// else position.point.y=terrain_height+MIN_HEIGHT_ABOVE_GROUND;
}

void Player::getFrontBackPlane(float *plane)
{
    JPoint v;
    jpoint_t p;

    getPosition(&p);
    getViewVec(&v.point);
    v.normalize();
    plane[0]=v.point.x;
    plane[1]=v.point.y;
    plane[2]=v.point.z;
    plane[3]=-(plane[0]*p.x+plane[1]*p.y+plane[2]*p.z);
}


void Player::getFrustumPlanes(float plane[6][4])
{
    JPoint v;
    jpoint_t p;

    getPosition(&p);
    getViewVec(&v.point);
    v.normalize();
    plane[PLANE_MINUS_Z][0]=v.point.x;
    plane[PLANE_MINUS_Z][1]=v.point.y;
    plane[PLANE_MINUS_Z][2]=v.point.z;
    plane[PLANE_MINUS_Z][3]=-0.1f-(plane[PLANE_MINUS_Z][0]*p.x
                                   +plane[PLANE_MINUS_Z][1]*p.y
                                   +plane[PLANE_MINUS_Z][2]*p.z);

    plane[PLANE_PLUS_Z][0]=-v.point.x;
    plane[PLANE_PLUS_Z][1]=-v.point.y;
    plane[PLANE_PLUS_Z][2]=-v.point.z;
    plane[PLANE_PLUS_Z][3]=+CLIP_RANGE-(plane[PLANE_PLUS_Z][0]*p.x
                                        +plane[PLANE_PLUS_Z][1]*p.y
                                        +plane[PLANE_PLUS_Z][2]*p.z);

    v.set(0.8f,0.0f,4.0f/3.0f);
    v.rotateX(rotation.point.x);
    v.rotateY(rotation.point.y);
    v.normalize();
    plane[PLANE_MINUS_X][0]=v.point.x;
    plane[PLANE_MINUS_X][1]=v.point.y;
    plane[PLANE_MINUS_X][2]=v.point.z;
    plane[PLANE_MINUS_X][3]=-(plane[PLANE_MINUS_X][0]*p.x
                              +plane[PLANE_MINUS_X][1]*p.y
                              +plane[PLANE_MINUS_X][2]*p.z);

    v.set(-0.8f,0.0f,4.0f/3.0f);
    v.rotateX(rotation.point.x);
    v.rotateY(rotation.point.y);
    v.normalize();
    plane[PLANE_PLUS_X][0]=v.point.x;
    plane[PLANE_PLUS_X][1]=v.point.y;
    plane[PLANE_PLUS_X][2]=v.point.z;
    plane[PLANE_PLUS_X][3]=-(plane[PLANE_PLUS_X][0]*p.x
                             +plane[PLANE_PLUS_X][1]*p.y
                             +plane[PLANE_PLUS_X][2]*p.z);

    v.set(0.0f,0.8f,1.0f);
    v.rotateX(rotation.point.x);
    v.rotateY(rotation.point.y);
    v.normalize();
    plane[PLANE_MINUS_Y][0]=v.point.x;
    plane[PLANE_MINUS_Y][1]=v.point.y;
    plane[PLANE_MINUS_Y][2]=v.point.z;
    plane[PLANE_MINUS_Y][3]=-(plane[PLANE_MINUS_Y][0]*p.x
                              +plane[PLANE_MINUS_Y][1]*p.y
                              +plane[PLANE_MINUS_Y][2]*p.z);

    v.set(0.0f,-0.8f,1.0f);
    v.rotateX(rotation.point.x);
    v.rotateY(rotation.point.y);
    v.normalize();
    plane[PLANE_PLUS_Y][0]=v.point.x;
    plane[PLANE_PLUS_Y][1]=v.point.y;
    plane[PLANE_PLUS_Y][2]=v.point.z;
    plane[PLANE_PLUS_Y][3]=-(plane[PLANE_PLUS_Y][0]*p.x
                             +plane[PLANE_PLUS_Y][1]*p.y
                             +plane[PLANE_PLUS_Y][2]*p.z);
}


void Player::getLocation(float location[3])
{
    location[0]=this->position.point.x;
    location[1]=this->position.point.y;
    location[2]=this->position.point.z;
}

void Player::getOrientation(float front[3], float right[3])
{
    JPoint point(0.0, 0.0, 1.0);
    point.rotateX(rotation.point.x);
    point.rotateY(rotation.point.y);
    
    front[0]=point.point.x;
    front[1]=point.point.y;
    front[2]=point.point.z;
    
    point.set(1.0, 0.0, 0.0);
    point.rotateZ(rotation.point.z);
    point.rotateX(rotation.point.x);
    point.rotateY(rotation.point.y);
    
    right[0]=point.point.x;
    right[1]=point.point.y;
    right[2]=point.point.z;
}

Vector Player::getMovementVector()
{
    float front[3], right[3];
    
    getOrientation(front, right);
    Vector f(front), r(right);
    
    return speed * f + getStrifeVector(f, r);
}


void Player::strifeForward(bool active)
{
    ls_message("forward = %d", active);
    strife.forward=active;
}
void Player::strifeBackward(bool active)
{
    strife.backward=active;
}
void Player::strifeRight(bool active)
{
    strife.right=active;
}
void Player::strifeLeft(bool active)
{
    strife.left=active;
}

Vector Player::getStrifeVector(const Vector & front, const Vector & right)
{
    Vector v(0,0,0);
    Vector r(right);
    r[1]=0.0; // we want sideward strifing to be only horizontal
    r.normalize();
    if (strife.forward) v += front;
    if (strife.backward) v -= front;
    if (strife.right) v += r;
    if (strife.left) v -= r;
    v *= STRIFE_SPEED;
    return v;
}
